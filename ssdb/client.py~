from __future__ import with_statement
from itertools import chain, starmap, izip_longest
import datetime
import sys
import warnings
import time as mod_time
from ssdb._compat import (b, basestring, bytes, imap, iteritems, iterkeys,
                          itervalues, izip, long, nativestr, urlparse, unicode)
from ssdb.connection import ConnectionPool
from ssdb.exceptions import (
    ConnectionError,
    DataError,
    SSDBError,
    ResponseError,
    WatchError,
    NoScriptError,
    ExecAbortError,
    )

SYM_EMPTY = b('')

def get_integer(name, num):
    if not isinstance(num, int):
        raise ValueError('``%s`` must be a integer' % name)
    return num

def get_nonnegative_integer(name, num):
    is_valid = isinstance(num, int) and num >= 0
    if not is_valid:
        raise ValueError('``%s`` must be a nonnegative integer' % name)
    return num

def get_positive_integer(name, num):
    is_valid = isinstance(num, int) and num > 0
    if not is_valid:
        raise ValueError('``%s`` must be a positive integer' % name)
    return num

def get_negative_integer(name, num):
    is_valid = isinstance(num, int) and num < 0
    if not is_valid:
        raise ValueError('``%s`` must be a negative integer' % name)
    return num
        
def list_or_arg(keys, args):
    #returns a single list combining keys and args
    try:
        iter(keys)
        # a string or bytes instance can be iterated, but indicates keys wasn't
        # passed as a list
        if isinstance(keys, (basestring, bytes)):
            key = [keys]
    except TypeError:
        keys = [keys]
    if args:
        keys.extend(args)
    return keys

def timestamp_to_datetime(response):
    """
    Converts a unix timestamp to a Python datetime object.
    """
    if not response:
        return None
    try:
        response = int(response)
    except ValueError:
        return None
    return datetime.datetime.fromtimestamp(response)

def string_keys_to_dict(key_string, callback):
    return dict.fromkeys(key_string.split(), callback)

def list_to_dict(lst):
    return dict(izip_longest(*[iter(lst)] * 2, fillvalue=None))

def list_to_int_dict(lst):
    return {k:int(v) for k,v in list_to_dict(lst).items()}

def dict_to_list(dct):
    lst = []
    for key, value in dct.iteritems():
        lst.append(key)
        lst.append(value)
    return lst

def dict_merge(*dicts):
    merged = {}
    [merged.update(d) for d in dicts]
    return merged

def parse_debug_object(response):
    """
    Parse the results of ssdb's DEBUG OBJECT command into a Python dict
    """
    # The 'type' of the object is the first item in the response, but isn't
    # prefixed with
    response = nativestr(response)
    response = 'type:' + response
    response = dict([kv.split(':') for kv in response.split()])

    # parse some expected int values from the string response note: this cmd
    # isn't spec'd so these may not appear in all ssdb versions
    int_fields = ('refcount', 'serializedlength', 'lru', 'lru_seconds_idle')
    for field in int_fields:
        if field in response:
            response[field] = int(response[field])
    return response

def parse_object(response, infotype):
    """
    Parse the results of an OBJECT command
    """
    if infotype in ('idletime', 'refcount'):
        return int(response)
    return response


class StrictSSDB(object):
    """
    Implementation of the SSDB protocol.

    This abstract class provides a Python interface to all SSDB commands and an
    implementation of the SSDB protocol.
    
    Connection and Pipeline derive from this, implementing how the commands are
    sent and received to the SSDB server
    """

    RESPONSE_CALLBACKS = dict_merge(
        string_keys_to_dict(
            'set del exists '
            'hset hdel hclear hexists '
            'zset zdel zclear zexists',
            lambda r: bool(int(r[0]))
        ),
        string_keys_to_dict(
            'get hget',
            lambda r: r[0]
        ),
        string_keys_to_dict(
            'incr decr multi_set multi_del '
            'hincr hdecr hsize multi_hset multi_hdel '
            'zincr zdecr zsize multi_zset multi_zdel zget zrank zrrank',
            lambda r: int(r[0])
        ),
        string_keys_to_dict(
            'multi_get scan rscan '
            'multi_hget hscan hrscan '
            'multi_zget zscan zrscan',            
            list_to_dict
        ),
        string_keys_to_dict(
            'multi_zget zscan zrscan zrange zrrange',
            list_to_int_dict
        ),        
        string_keys_to_dict(
            'keys hkeys hlist zkeys zlist',
            lambda r: r
        ),        
        {
            'zget1': lambda r: int(r[0]),
        }
    )

    def __init__(self, host='localhost', port=8888, socket_timeout=None,
                 connection_pool=None, charset='utf-8', errors='strict',
                 decode_responses=False):
        if not connection_pool:
            kwargs = {
                'host': host,
                'port': port,
                'socket_timeout': socket_timeout,
                'encoding': charset,
                'encoding_errors': errors,
                'decode_responses': decode_responses,
            }
            connection_pool = ConnectionPool(**kwargs)
        self.connection_pool = connection_pool
        self.response_callbacks = self.__class__.RESPONSE_CALLBACKS.copy()

    def __repr__(self):
        return "%s<%s>" % (type(self).__name__, repr(self.connection_pool))

    def set_response_callback(self, command, callback):
        """
        Set a custom Response Callback
        """
        self.response_callbacks[command] = callback    

    #### COMMAND EXECUTION AND PROTOCOL PARSING ####
    def execute_command(self, *args, **options):
        """
        Execute a command and return a parsed response.
        """
        pool = self.connection_pool
        command_name = args[0]
        connection = pool.get_connection(command_name, **options)
        try:
            connection.send_command(*args)
            return self.parse_response(connection, command_name, **options)
        except ConnectionError:
            connection.disconnect()
            connection.send_command(*args)
            return self.parse_response(connection, command_name, **options)
        finally:
            pool.release(connection)

    def parse_response(self, connection, command_name, **options):
        """
        Parses a response from the ssdb server
        """
        response = connection.read_response()
        if command_name in self.response_callbacks and len(response):
            status = nativestr(response[0])
            if status == 'ok' :
                return self.response_callbacks[command_name](response[1:],
                                                             **options)
            if status == 'not_found':
                return None
                #raise DataError('Not Found')
        return response

    #### KEY/VALUES OPERATION ####    
    def set(self, name, value):
        """
        Set the value at key ``name`` to ``value``
        """
        return self.execute_command('set', name, value)

    def get(self, name):
        return self.execute_command('get', name)

    def delete(self, name):
        """
        Delete the value at key ``name``
        """
        return self.execute_command('del', name)

    def exists(self, name):
        return self.execute_command('exists', name)

    def incr(self, name, num=1):
        num = get_positive_integer('num', num)
        return self.execute_command('incr', name, num)

    def decr(self, name, num=1):
        num = get_positive_integer('num', num)
        return self.execute_command('decr', name, num)    

    def multi_set(self, **kvs):
        return self.execute_command('multi_set', *dict_to_list(kvs))

    def multi_get(self, *keys):
        return self.execute_command('multi_get', *keys)

    def multi_delete(self, *keys):
        return self.execute_command('multi_del', *keys)

    def keys(self, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)
        return self.execute_command('keys', key_start, key_end, limit)

    def scan(self, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('scan', key_start, key_end, limit)

    def rscan(self, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('rscan', key_start, key_end, limit)

    #### HASH OPERATION ####
    def hset(self, name, key, value):
        return self.execute_command('hset', name, key, value)

    def hget(self, name, key):
        return self.execute_command('hget', name, key)

    def hdelete(self, name, key):
        return self.execute_command('hdel', name, key)

    def hclear(self, name):
        return self.execute_command('hclear', name)

    def hexists(self, name, key):
        return self.execute_command('hexists', name, key)

    def hincr(self, name, key, num=1):
        num = get_positive_integer('num', num)        
        return self.execute_command('hincr', name, key, num)

    def hdecr(self, name, key, num=1):
        num = get_positive_integer('num', num)        
        return self.execute_command('hdecr', name, key, num)

    def hsize(self, name):
        return self.execute_command('hsize', name)

    def multi_hset(self, name, **kvs):
        return self.execute_command('multi_hset', name, *dict_to_list(kvs))

    def multi_hget(self, name, *keys):
        return self.execute_command('multi_hget', name, *keys)

    def multi_hdelete(self, name, *keys):
        return self.execute_command('multi_hdel', name, *keys)

    def hkeys(self, name, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)
        return self.execute_command('hkeys', name, key_start, key_end, limit)

    def hlist(self, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)
        return self.execute_command('hlist', key_start, key_end, limit)    

    def hscan(self, name, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('hscan', name, key_start, key_end, limit)

    def hrscan(self, name, key_start, key_end, limit=10):
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('hrscan', name, key_start, key_end, limit)

    #### HASH OPERATION ####
    def zset(self, name, key, score=1):
        score = get_integer('score', score)        
        return self.execute_command('zset', name, key, score)

    def zget(self, name, key):
        return self.execute_command('zget', name, key)

    def zdelete(self, name, key):
        return self.execute_command('zdel', name, key)

    def zclear(self, name):
        return self.execute_command('zclear', name)

    def zexists(self, name, key):
        return self.execute_command('zexists', name, key)

    def zincr(self, name, key, num=1):
        num = get_positive_integer('num', num)        
        return self.execute_command('zincr', name, key, num)

    def zdecr(self, name, key, num=1):
        num = get_positive_integer('num', num)        
        return self.execute_command('zdecr', name, key, num)

    def zsize(self, name):
        return self.execute_command('zsize', name)

    def multi_zset(self, name, **kvs):
        for k,v in kvs.items():
            kvs[k] = get_integer(k, int(v))
        return self.execute_command('multi_zset', name, *dict_to_list(kvs))

    def multi_zget(self, name, *keys):
        return self.execute_command('multi_zget', name, *keys)

    def multi_zdelete(self, name, *keys):
        return self.execute_command('multi_zdel', name, *keys)

    def zlist(self, name_start, name_end, limit=10):
        limit = get_positive_integer('limit', limit)
        return self.execute_command('zlist', name_start, name_end, limit)

    def zkeys(self, name, key_start, score_start, score_end, limit=10):
        score_start = get_integer('score_start', score_start)
        score_end = get_integer('score_end', score_end)        
        limit = get_positive_integer('limit', limit)
        return self.execute_command('zkeys', name, key_start, score_start,
                                    score_end, limit)    

    def zscan(self, name, key_start, score_start, score_end, limit=10):
        score_start = get_integer('score_start', score_start)
        score_end = get_integer('score_end', score_end)                
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('zscan', name, key_start, score_start,
                                    score_end, limit)

    def zrscan(self, name, key_start, score_start, score_end, limit=10):
        score_start = get_integer('score_start', score_start)
        score_end = get_integer('score_end', score_end)        
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('zrscan', name, key_start, score_start,
                                    score_end, limit)

    def zrank(self, name, key):
        return self.execute_command('zrank', name, key)

    def zrrank(self, name, key):
        return self.execute_command('zrrank', name, key)

    def zrange(self, name, offset, limit):
        offset = get_nonnegative_integer('offset', offset)        
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('zrange', name, offset, limit)

    def zrrange(self, name, offset, limit):
        offset = get_nonnegative_integer('offset', offset)        
        limit = get_positive_integer('limit', limit)        
        return self.execute_command('zrrange', name, offset, limit)    
    
        
class SSDB(StrictSSDB):
    """
    Provides backwards compatibility with older versions of ssdb-py that changed
    arguments to some commands to be more Pythonic, sane, or by accident.
    """
    RESPONSE_CALLBACKS = dict_merge(
        StrictSSDB.RESPONSE_CALLBACKS,
        {
            'TTL': lambda r: r != -1 and r or None,
            'PTTL': lambda r: r != -1 and r or None,
        }
    )
